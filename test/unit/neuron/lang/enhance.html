<div id="lang-enhance-container">
    <p></p>
    <p></p>
    <div></div>
    <select style="display:none">
        <option></option>
        <option></option>
        <option></option>
        <option></option>
    </select>
</div>

<script>

describe('Neuron:lang/enhance', function(){


describe('KM.mix(receiver, sender, override, copylist)', function(){
    it("always returns the receiver itself", function(){
        var receiver = {
            a: 1,
            b: 2,
            c: 3
        };
    
        expect(KM.mix(receiver, {a: 2})).toBe(receiver);
        expect(KM.mix(receiver, {a: 1}, false)).toBe(receiver);
        expect(KM.mix(receiver, {a: 1}, false, ['b', 'c'])).toBe(receiver);
    });

    it('could mix an object to the receiver', function(){
        var receiver = {
                a: 1,
                b: 2,
                o: {
                    a: 1,
                    b: 2
                }
            },
            
            sender = {
                b: 22,
                c: 3,
                o: {
                    c: 3
                },
                
                d1: {
                    a: 1
                },
                
                d2: {
                    a: 2
                },
                
                d3: 3
            };
            
        // default to override
        KM.mix(receiver, sender);
            
        expect( receiver.a ).toBe(1);
        expect( receiver.b ).toBe(22);
        
        // override
        expect( receiver.o.a ).toBe(undefined);
        expect( receiver.o.c ).toBe(3);
    });
    
    it('could mix an object to the receiver, excluding the existed member', function(){
        var receiver2 = {
                a: 1,
                b: 2,
                o: {
                    a: 1,
                    b: 2
                }
            },
            
            sender = {
                b: 22,
                c: 3,
                o: {
                    c: 3
                },
                
                d1: {
                    a: 1
                },
                
                d2: {
                    a: 2
                },
                
                d3: 3
            };
            
        // no override
        KM.mix(receiver2, sender, false);
            
        // no override
        expect( receiver2.b ).toBe(2);
        expect( receiver2.o.a ).toBe(1);
    });
    
    it('could mix an object to the receiver, according to a copy list', function(){
        var receiver3 = {
                a: 1,
                b: 2,
                o: {
                    a: 1,
                    b: 2
                }
            },
            
            sender = {
                b: 22,
                c: 3,
                o: {
                    c: 3
                },
                
                d1: {
                    a: 1
                },
                
                d2: {
                    a: 2
                },
                
                d3: 3
            };
            
        // override by a copy list
        KM.mix(receiver3, sender, true, ['d1', 'd2']);
            
        expect( receiver3.b ).toBe(2);
        expect( receiver3.d1.a ).toBe(1);
        expect( receiver3.d3 ).toBe(undefined);
    });
    
    it('could mix an object to the receiver, with mixed condition', function(){
        var receiver4 = {
                a: 1,
                b: 2,
                o: {
                    a: 1,
                    b: 2
                }
            },
            
            sender = {
                b: 22,
                c: 3,
                o: {
                    c: 3
                },
                
                d1: {
                    a: 1
                },
                
                d2: {
                    a: 2
                },
                
                d3: 3
            };
            
        KM.mix(receiver4, sender, false, ['o', 'd1', 'd3']);
        // not override
        expect( receiver4.o.c ).toBe(undefined);
        expect( receiver4.o.a ).toBe(1);
        
        expect( receiver4.d2 ).toBe(undefined);
        expect( receiver4.d3 ).toBe(3);
    });
});


describe('KM.each()', function(){
    it("returns undefined", function(){
        var c = {
                a: 1,
                b: 2
            },
            
            obj_receiver = {};
            
        var ret = KM.each(c, function(v, k){
            obj_receiver[k] = v;
        });
    
        expect(ret).toBe(undefined);
    });

    it('could iterate an object which created using {}', function(){
        var c = {
                a: 1,
                b: 2
            },
            
            obj_receiver = {};
            
        KM.each(c, function(v, k){
            obj_receiver[k] = v;
        });
        
        expect( obj_receiver.a ).toBe(1);
        expect( obj_receiver.b ).toBe(2);
    });
    
    it('would ignore the prototype', function(){
        function C(){};
        
        C.prototype = {
            a: 1
        };
        
        var d = new C,
            obj_receiver2 = {};
            
        d.b = 2;
            
        KM.each(d, function(v, k){
            obj_receiver2[k] = v;
        });
        
        expect( obj_receiver2.a ).toBe(undefined);
        expect( obj_receiver2.b ).toBe(2);
    });
    
    
    it('could iterate an array', function(){
        var a = [1,2],
            arr_receiver = [];
            
        a.a = a;
        
        KM.each(a, function(v, i){
            arr_receiver[i] = v;
        });
        
        expect( arr_receiver[0] ).toBe(1);
        expect( arr_receiver[1] ).toBe(2);
    });
});


describe('KM.clone(object, filter)', function(){
    
    it('could clone an object', function(){
        // preparing origin data >>>>>>>>>>>>>>>>>>>>>>>>>>>
        var o = {
                a: {
                    a: 1,
                    b: 2,
                    c: {
                        d: {
                            e: 1
                        }
                    }
                },
                
                b: {
                    a: 11,
                    b: 22
                }
            },
            
            receiver;
            
        o.c = o;
        
        // receiver ------------------------------------
        // clone an object
        receiver = KM.clone(o);
        
        // test recursive object
        expect( receiver.c.a.b ).toBe(2);
        
        // alter original and cloned data
        o.d = 3;
        expect( receiver.d ).toBe(undefined);
        
        // alter recursive object
        o.c.a.c.d.e = 11;
        expect( receiver.c.a.c.d.e ).toBe(1);
        
        receiver.a.a = 11;
        expect( o.a.a ).toBe(1);    
    });
    
    it('could clone members of an object into a receiver', function(){
        var o2 = {
                a: {
                    a: 1,
                    b: 2,
                    c: {
                        d: {
                            e: 1
                        }
                    }
                },
                
                b: {
                    a: 11,
                    b: 22
                }
            },
            
            receiver2;
            
        o2.c = o2;
            
        // receiver2 ------------------------------------
        // clone an object into a receiver
        var receiver2 = KM.clone(o2, false);
        
        // test recursive object
        expect( receiver2.c.a.b ).toBe(2);
        
        // alter original and cloned data
        o2.d = 3;
        expect( receiver2.d ).toBe(undefined);
        
        // alter recursive object
        o2.c.a.c.d.e = 11;
        expect( receiver2.c.a.c.d.e ).toBe(1);
        
        receiver2.a.a = 11;
        expect( o2.a.a ).toBe(1);
    });
    
    
    it('could clone an array', function(){
        var array = [1, 2, 3, 4],
            cloned;
            
        array.a = array;
            
        cloned = KM.clone(array);
        
        cloned[0] = 11;
        array[2] = 33;
        
        expect(cloned.length).toBe(4);
        expect(array[0]).toBe(1);
        expect(cloned[2]).toBe(3);
        
        // recursive member
        expect(cloned.a[2]).toBe(3);
    });
    
    it('could clone an mixed object', function(){
        var foo = function(){},
            p = document.getElementsByTagName('p')[0],
            obj = [
                {
                    a: 1,
                    b: [1, 2]
                },
                
                foo,
                p
            ],
            
            cloned = KM.clone(obj);
            
        obj[0].b[0] = 11;
            
        expect(cloned[0].b[0]).toBe(1);
        expect(cloned[1]).toBe(foo);
        expect(cloned[2]).toBe(p);
    
    });
    
    
    it('could unlink the reference to its prototype', function(){
        var o3 = {
                a: {
                    a: 1,
                    b: 2,
                    c: {
                        d: {
                            e: 1
                        }
                    }
                },
                
                b: {
                    a: 11,
                    b: 22
                }
            },
            
            receiver3;
            
        o3.c = o3;
            
        function O3(){};
        O3.prototype = o3;
            
        // receiver3 ------------------------------------
        // unlink the reference of an object
        receiver3 = KM.clone(new O3);
        
        // change the value of a property in receiver3
        receiver3.a.a = 11;
        expect( o3.a.a ).toBe(1); // no affect with its prototype
        
        // the change of the prototype would not affect its instances
        o3.a.b = 22;
        expect( receiver3.a.b ).toBe(2)
    
    });
    
    
    it('could use clone filter', function(){
        var o32 = {
                a: {
                    a: 1,
                    b: 2,
                    c: {
                        d: {
                            e: 1
                        }
                    },
                    
                    d: {
                        e: {
                            f: 1
                        }
                    }
                },
                
                b: {
                    a: 11,
                    b: 22
                },
                
                c: 1,
                
                d: {
                    a: 11,
                    b: 22
                }
            },
            
            receiver32;
            
        function O32(){};
        O32.prototype = o32;
        
        // !important
        // * receiver4 * ------------------------------------
        // test filter
        var receiver32 = KM.clone(new O32, function(v, k, d){
        
            // only copy the first depth
            return d === 1;
            
        });
        
        expect(!!receiver32.a).toBe(true);
        expect(receiver32.a.a).toBe(undefined);
        expect(receiver32.c).toBe(1);
        
    });
    
    it("could successfully clone a recursive object", function(){
        var a = {
            b: 1
        };
        
        // recursive
        a.a = a;
    
        var c = KM.clone(a);
    
        expect(c.a.a.a.b).toBe(1);
    });   
});


describe('KM.bind()', function(){
    it('could bind a normal fn', function(){
        var context = {
                a: 1
            },
            
            obj = {
                a: 2,
                fn: function(){
                    return this.a;
                }
            },
            
            fn;
            
        fn = KM.bind(obj.fn, context);
        expect(fn()).toBe(1);
        
    });
    
    
    it('could bind a singleton method', function(){    
        var context = {
                a: 1
            },
            
            obj2 = {
                a: 3,
                fn: function(){
                    return this.a;
                },
                
                bindFn: function(){
                    KM.bind('fn', context);
                }
            };
    
        obj2.bindFn();
        expect(obj2.fn()).toBe(3);
    });
    
    it("could bind an instance method", function(){
        function A(){
            KM.bind('fn', this);  
        };
        
        A.prototype = {
            fn: function(){
                return this.a;
            },
            
            a: 1
        };
        
        var obj = {
            fn: new A().fn,
            
            a: 2
        }
    
        expect(obj.fn()).toBe(1);
    });
        
});


describe('KM.makeArray(array, host)', function(){
    function checkArray(item){
        var converted = KM.makeArray(item);
        
        expect( KM.isArray( converted ) ).toBe(true);
    };
    
    describe("KM.makeArray(array)", function(){
        it("test env requirements", function(){
            expect(!!document.getElementById).toBe(true);
            expect(!!document.getElementsByTagName).toBe(true);
        });
        
        it('would return the array itself, if alreay an array', function(){
            checkArray([]);
            
            var arr = [1, document.getElementsByTagName('p')];
            expect( KM.makeArray(arr) ).toBe(arr);
            
        });
        
        it("KM.makeArray(undefined) -> KM.makeArray() -> []", function(){
            var result = KM.makeArray(undefined);
        
            expect(result.length).toBe(0);
        });
        
        it("KM.makeArray(false) -> [false]", function(){
            var result = KM.makeArray(false);
        
            expect(result.length).toBe(1);
            expect(result[0]).toBe(false);
        });
        
        
        it("KM.makeArray(null) -> []", function(){
            var result = KM.makeArray(null);
        
            expect(result.length).toBe(0);
        });
        
        it('would wrap non-array objects and numeric variables', function(){
            checkArray();
            expect( KM.makeArray()[0] ).toBe(undefined);
            
            checkArray(null);
            expect( KM.makeArray(null)[0] ).toBe(undefined);
            
            checkArray(123);
            expect( KM.makeArray(123)[0] ).toBe(123);
            
            checkArray('STRING');
            expect( KM.makeArray('STRING')[0] ).toBe('STRING');
            
            checkArray(window);
            expect( KM.makeArray(window)[0] ).toBe(window);
            
            checkArray(document.body);
            expect( KM.makeArray(document.body)[0] ).toBe(document.body);
        });
        
        it('would make NodeList as pure array', function(){
            var container = document.getElementById('lang-enhance-container');
        
            checkArray(container.getElementsByTagName('p'));
            checkArray(container.getElementsByTagName('select'));
            checkArray(container.getElementsByTagName('option'));
        });
    });
    
    
    describe("KM.makeArray(array, host)", function(){
        it("always returns the host itself", function(){
            var host = [],
                host2 = {};
        
            expect(KM.makeArray([1,2,3], host)).toBe(host);
            expect(KM.makeArray([1,2,3], host2)).toBe(host2);
        });
    
        it("would copy the array to the host", function(){
            var array = [1, 2],
                host = [],
                host2 = {},
                host3 = KM.DOM();
                
            KM.makeArray(array, host);
            KM.makeArray(array, host2);
            KM.makeArray(array, host3);
        
            expect(host[0]).toBe(1);
            expect(host2[0]).toBe(1);
            expect(host2[1]).toBe(2);
        });
        
        it("would manipulate the length property of the host", function(){
            var array = [1, 2],
                host = [],
                host2 = {},
                host3 = KM.DOM();
                
            KM.makeArray(array, host);
            KM.makeArray(array, host2);
            KM.makeArray(array, host3);
        
            expect(host.length).toBe(2);
            expect(host2.length).toBe(2);
            expect(host3.length).toBe(2);
        });
    });
});


describe("KM.makeArray.merge(array, host)", function(){
    it("will always treat the parameter as Array, even if it's not", function(){
        var obj = {
            length: 3
        },
        
        host = [];
        
        obj[0] = 1;
        obj[1] = 2;
        
        KM.makeArray.merge(obj, host);
    
        expect(host.length).toBe(3);
        expect(host[0]).toBe(1);
        expect(host[2]).toBe(undefined);
    });
    
    it("will throw error, if array is null", function(){
        expect().toBe();
    });
});


describe('semi-private: KM._overloadSetter()', function(){
    
    it('could overload a normal fn', function(){

        // test overload for normal function
        function setter(key, value){
            storage[key] = value;
        }
    
        var storage = {},
            batchSetter = KM._overloadSetter( setter );
        
        setter('a', 1);
        expect( storage.a ).toBe(1);
        
        batchSetter({
            a: 2,
            b: 3
        });
        expect( storage.a ).toBe(2);
        expect( storage.b ).toBe(3);
    });
    
    
    it('could overload a singleton method, and maintain the context', function(){    
        // test overload for singleton method
        var obj = {
                storage: {},
                setter: function(key, value){
                    this.storage[key] = value;
                },
                
                change: function(){
                    this.setter = KM._overloadSetter(this.setter);
                }
            };
            
        obj.setter('a', 1);
        expect( obj.storage.a ).toBe(1);
        
        obj.change();
        
        obj.setter({
            a: 2,
            b: 3
        });
        expect( obj.storage.a ).toBe(2);
        expect( obj.storage.b ).toBe(3);
    });
});


describe('semi-private: KM._onceBefore()', function(){
    it('could swap two methods', function(){
        var obj = {
                real: function(){
                    return this.a;
                },
                
                fake: function(){
                    this.a = 2;
                }
            };
            
        expect( obj.real() ).toBe(undefined);
        
        KM._onceBefore('real', 'fake', obj);
        
        expect( obj.real() ).toBe(2);
    });
    
    it('would not do evil to prototype chain', function(){
        var K = KM,
            C = K.Class({
                initialize: function(v){
                    this.v = v;
                },
                
                _real: function(){
                    return this.v ++;
                },
                
                print: function(){
                    return this.v - 1;
                }
            });
            
        K._onceBefore('print', '_real', C.prototype);
        
        var c = new C(1),
            c2 = new C(1);
            
        expect(c.print()).toBe(c2.print());
        expect(c.print()).toBe(c2.print());
        
        // will not ruin the prototype
        expect(new C(3).print()).toBe(3);
    });
});


describe('semi-private: KM._memoize(fn)', function(){
    it('could memoize the result of a function with number params', function(){
        function foo(){
            exec_counter ++;
            
            return Array.prototype.join.call(arguments, '_');
        };
        
        var exec_counter = 1,
            memoized_foo = KM._memoize( foo );
        
        memoized_foo(1, 2, 3); // exec_counter:2
        
        expect( memoized_foo(1, 2, 3) ).toBe('1_2_3');
        expect( memoized_foo(1, 2, 3) ).toBe('1_2_3');
        expect( exec_counter ).toBe(2);
        
        expect( memoized_foo(1, 2, 4) ).toBe('1_2_4');
        expect( exec_counter ).toBe(3);
        
    });
});

describe('KM.sub(template, data)', function(){
    

    it('could apply some parameters to a template', function(){
        var t = 'a:{a},b:{b}',
            p = {
                a: 1,
                b: 2
            };
            
        expect( KM.sub(t, p) ).toBe('a:1,b:2');
    });
    
    it('would not substitute escaped symbols', function(){
        var t = 'a:{a},b:\\{b}',
            p = {
                a: 1,
                b: 2
            };
            
        expect( KM.sub(t, p) ).toBe('a:1,b:{b}');
    });

    it('only substitute the most inner match of {}', function(){
        var t = 'a{{{a}}',
            p = {
                a: 1
            };
            
        expect( KM.sub(t, p) ).toBe('a{{1}');
    });
});


describe("KM._pushUnique(array, host)", function(){
    it("always returns the host", function(){
        var host = [1],
            array = [1,2,3];
    
        expect(KM._pushUnique(host, array)).toBe(host);
    });
    
    it("host can be an Object", function(){
        var obj_host = {},
            array = [1,2,3]
        
        
        expect(KM._pushUnique(obj_host, array)).toBe(obj_host);
        expect(obj_host[0]).toBe(1);
        expect(obj_host[1]).toBe(2);
        expect(obj_host.length).toBe(3);
    });
    
    it("could prevent duplication", function(){
        var host = [1, 2],
            array = [2, 3];
            
        KM._pushUnique(host, array);
    
        expect(host.length).toBe(3);
        expect(host.indexOf(2)).toBe(host.lastIndexOf(2));
    });
    
    it("could prevent duplication, even if `host` is an Array-like object", function(){
        var host = {},
            array = [2, 3];
        
        host[0] = 1;
        host[1] = 2;
        host.length = 2;
            
        KM._pushUnique(host, array);
    
        expect(host.length).toBe(3);
    });
});


});

</script>