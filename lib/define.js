// module define
// ---------------------------------------------------------------------------------------------------


// Legacy
// Old neuron modules will not define a real resolved id.
// We determine the new version by `env.map`
// Since 6.2.0, actually, neuron will and should no longer add file extension arbitrarily,
// because `commonjs-walker@3.x` will do the require resolve during parsing stage.
// But old version of neuron did and will add a `config.ext` to the end of the file.
// So, if commonjs-walker does so, we adds a 
function legacy_transform_id (id, env) {
  return env.map
    ? id
    : id + '.js';
}


// Method to define a module.

// **NOTICE** that `define` has no fault tolerance and type checking since neuron 2.0,
// because `define` method is no longer designed for human developers to use directly.
// `define` should be generated by some develop environment such as [cortex](http://github.com/cortexjs/cortex)
// @private

// @param {string} id (optional) module identifier
// @param {Array.<string>} dependencies ATTENSION! `dependencies` must be array of standard 
//   module id and there will be NO fault tolerance for argument `dependencies`. Be carefull!
// @param {function(...[*])} factory (require, exports, module)
// @param {Object=} options

// @return {undefined}
function define(id, dependencies, factory, options) {
  (options) || (options = {});

  // When define a module,
  // there is no context dependent
  var mod = define_by_id(id, options);
  mix(mod, options);

  // A single module might be defined more than once.
  // use this trick to prevent module redefining, avoiding the subsequent side effect.
  // mod.factory        -> already defined
  // X mod.exports  -> the module initialization is done
  if (!mod.factory) {
    mod.factory = factory;

    // if has dependencies
    if (dependencies.length) {
      mod.deps = dependencies;

      // ['a@0.0.1']  -> {'a' -> 'a@0.0.1'}
      generate_module_version_map(dependencies, mod.v);
      var asyncDeps = options.asyncDeps;
      if (asyncDeps) {
        generate_module_version_map(asyncDeps, mod.v);
      }
    }

    run_callbacks(mod, 'l');
  }
}


// Formally define a module with id,
// and dealing with the equivalent modules, merging registered callbacks.
function define_by_id (id, options) {
  var parsed = parse_id(id);

  // Legacy
  // in old times, main entry: 
  // - define(id_without_ext)
  // - define(pkg) <- even older
  // now, main entry: define(id_with_ext)
  if (parsed.p) {
    id = legacy_transform_id(id, options);
    parsed.p = legacy_transform_id(parsed.p, options);
  }

  var pkg = format_package_id(parsed);
  var mod = mods[id];
  if (!mod) {
    mod = create_mod(parsed, id, pkg);
  }

  if (options.main) {
    // If define a main module,
    // `id === pkg` must be true 
    //    'a@1.2.9/index' is equivalent to 'a@1.2.9'
    // But mods[pkg] might exist
    var modMain = mods[pkg];

    if (modMain && modMain !== mod) {
      // Combine registered callbacks of `mods['a@1.2.9']`
      mod.l = mod.l.concat(modMain.l);
      // Clean
      modMain.l.length = 0;
    }
    mods[pkg] = mod;
  }

  return mod;
}

// @private
// create version info of the dependencies of current module into current sandbox
// @param {Array.<string>} modules no type detecting
// @param {Object} host

// ['a@~0.1.0', 'b@~2.3.9']
// -> 
// {
//     a: '~0.1.0',
//     b: '~2.3.9'
// }
function generate_module_version_map(modules, host) {
  modules.forEach(function(mod) {
    var name = mod.split('@')[0];
    host[name] = mod;
  });
}
