// # Neuron Core 

// ## CommonJS
// Neuron 3.x or newer is not the implementation of any CommonJs proposals
// but [module/1.0](http://wiki.commonjs.org/wiki/Modules/1.0), one of the stable CommonJs standards only.
// And by using neuron and [cortex](http://github.com/kaelzhang/cortex), user could write module/1.0 modules.

// ## Naming Conventions
// All naming of variables should accord to this.
// `'a@1.0.0/relative'`

// ### package 
// The package which the current module belongs to.
// - name or package name: {string}  package `name`: 'a'
// - package or package id: {string}    contains package `name` and `version` and the splitter `'@'`. 'a@1.0.0' for instance.

// ### module
// A package is consist of several module objects.
// - mod: {object} the module object. use `mod` instead of `module` to avoid confliction
// - id or module id: the descripter that contains package name, version, and path information
//      {string} for example, `'a@1.0.0/relative'` is a module id(entifier)

// ### version
// Package version: '1.0.0'

// ### main entry
// The module of a package that designed to be accessed from the outside


// map -> identifier: module
// Expose the object for debugging
// @expose
var mods = neuron.mods = {};


// module define
// ---------------------------------------------------------------------------------------------------

// Method to define a module, `define` has no fault tolerance in neuron 2.0,
// because `define` method is no longer designed for human to use.
// `define` should be generated by some develop environment such as [cortex](http://ctx.io)
// @private

// **NOTICE** that `define` method is not used by developers directly,
// so there's no type checking, and no fault tolerance.

// @param {string} identifier (optional) module identifier
// @param {Array.<string>} dependencies ATTENSION! `dependencies` must be array of standard module identifier and
//    there will be NO fault tolerance for argument `dependencies`. Be carefull!
// @param {function(...[*])} factory
// @param {Object=} options

// @return {undefined}
function define(identifier, dependencies, factory, options) {
  options = options || {};

  var mod = getModuleById(identifier, NULL, {
    a: true,
    m: options.main
  });
  mix(mod, options);

  // a single module might be defined more than once.
  // use this trick to prevent module redefining, avoiding the subsequent side effect.
  // mod.f        -> already defined
  // X mod.exports  -> the module initialization is done
  if (!mod.f) {
    mod.f = factory;

    // if has dependencies
    if (dependencies.length) {
      mod.deps = dependencies;

      // ['a@0.0.1']  -> {'a' -> 'a@0.0.1'}
      generateModuleVersionMap(dependencies, mod.v);
      if (options.asyncDeps) {
        generateModuleVersionMap(options.asyncDeps, mod.v);
      }

      // pending
      loadDependencies(dependencies, function() {
        ready(mod);
        // emit(mod, 'ready');
      }, mod);

    } else {
      // for standalone modules, run factory immediately.
      // emit(mod, 'ready');
      ready(mod);
    }

    // emit(mod, 'define');
  }
}


function ready (mod) {
  // execute pending callbacks and clean
  mod.c.forEach(function(c) {
    c(mod);
  });
  mod.c.length = 0;
  delete mod.c;

  // never delete `mod.v`, coz `require` method might be executed after module factory executed
  // ```js
  // module.exports = {
  //    abc: function() {
  //        return require('b'); 
  //    }
  // }
  // ```
}


// @private
// create version info of the dependencies of current module into current sandbox
// @param {Array.<string>} modules no type detecting
// @param {Object} host

// ['a@~0.1.0', 'b@~2.3.9']
// -> 
// {
//     a: '~0.1.0',
//     b: '~2.3.9'
// }
function generateModuleVersionMap(modules, host) {
  modules.forEach(function(mod) {
    var name = mod.split('@')[0];
    host[name] = mod;
  });
}


// Generate the exports
// @param {Object} mod
function getExports(mod) {
  if (mod.loaded) {

    // In node.js, if there are circular dependencies, `module.exports` will be `{}` by default,
    // while `mod.exports` will be undefined in neuron,
    // which is different from here.

    // Actually, neuron(~5.0.0) could not handle static circular dependencies, 
    // in which situation, method `ready(mod)` will never be called.
    // But, static circular dependencies is a piece of cake for builders, such like [cortex](http://github.com/cortexjs/cortex)

    // If `'exports'` is not in mod, we treated it as a circular dependency suspectedly.
    if (!('exports' in mod)) {
      neuron.emit('circular', {
        mod: mod
      });
    }

    return mod.exports;
  }

  // #82: since 4.5.0, a module only initialize factory functions when `require()`d.
  // A single module might
  return generateExports(mod);
}


function generateExports (mod) {
  var exports = {};
  // @expose
  var module = {
    exports: exports
  };

  // # 85
  // Before module factory being invoked, mark the module as `loaded`
  // so we will not execute the factory function again.
  
  // `mod.loaded` indicates that a module has already been `require()`d
  // When there are cyclic dependencies, neuron will not fail.
  mod.loaded = true;

  // to keep the object mod away from the executing context of factory,
  // use `factory` instead `mod.f`,
  // preventing user from fetching runtime data by 'this'
  var factory = mod.f;
  factory(createRequire(mod), exports, module);
  // delete mod.f;

  // during the execution of `factory`, `module.exports` might be changed
  // exports:
  // TWO ways to define the exports of a module
  // 1. 
  // exports.method1 = method1;
  // exports.method2 = method2;

  // 2.
  // module.exports = {
  //        method1: method1,
  //        method2: method2
  // }

  // priority: 2 > 1
  return mod.exports = module.exports;
}


// function emit (mod, type) {
//   neuron.emit(type, {
//     mod: mod
//   });
// }


// module load
// ---------------------------------------------------------------------------------------------------


// @private
// @param {Array.<String>} dependencies
// @param {(function()} callback
// @param {Object} env Environment for cyclic detecting and generating the uri of child modules
// {
//     r: {string} the uri that its child dependent modules referring to
//     n: {string} namespace of the current module
// }
function loadDependencies(dependencies, callback, env) {
  var counter = dependencies.length;

  dependencies.forEach(function(id) {
    if (id) {
      var mod = getModuleById(id, env);
      registerModuleLoadCallback(mod, function() {
        if (--counter === 0) {
          callback();

          // prevent memleak
          callback = NULL;
        }
      }, env);

      // Prevent bad dependencies
    } else {
      --counter;
    }
  });
}


function useModule (mod, callback) {
  registerModuleLoadCallback(mod, function (mod) {
    callback(getExports(mod));
  });
}


// provide a module
// method to provide a module
// @param {Object} mod
// @param {function()} callback
function registerModuleLoadCallback(mod, callback) {
  mod.c
    ? mod.c.push(callback)
    : callback(mod);

  // everytime we encounter a module which is depended by the other module, `'use'` event fires 
  neuron.emit('use', {
    mod: mod,

    // prevent duplicate loading
    // @type {boolean=} whether the module is already fetched, i.e. we don't need to fetch it from the remote server
    defined: !! mod.f
  });
}


// use the sandbox to specify the environment for every id that required in the current module 
// @param {Object} env The object of the current module.
// @return {function}
function createRequire(env) {
  var require = function(id) {
    var mod = getModuleById(env.v[id] || id, env, {
      s: true
    });
    return getExports(mod);
  };

  // @param {string} id Module identifier. 
  // Since 4.2.0, we only allow to asynchronously load a single module
  require.async = function(id, callback) {
    var mod = getModuleById(id, env);

    if (!mod.main) {
      if (isPathRelative(id)) {
        // If user try to load a non-entry module, it will get a 404 response
        mod.async = true;
      } else {
        // We only allow to `require.async` main module or entries of the current package 
        return;
      }
    }

    useModule(mod, callback);
  };

  return require;
}


// cases:

// 1. calculate relative paths 
// 2. load modules

// ```
// 'a@0.0.1/b.js'
// -> define('a@0.0.1/b', ['./c'], factory, {main: true});
// if main entry is not 
// -> {
//     'a@0.0.1/b': mod_b,
//     'a@0.0.1': mod_b
// }
// -> 'a/0.0.1/a.js'

// 'a@0.0.1/c'
// -> define('a@0.0.1/c', [], factory, {});
// -> {
//     'a@0.0.1/c': mod_c
// }
// ```

// get a module by id. if not exists, a ghost module(which will be filled after its first `define`) will be created
// @param {string} id
// @param {Object} env the environment module, 
// @param {Object} options
// - m: {} whether is main module
// - s: {} whether is strict definition. if a module is not found, it will throw errors instead of creating a new module 
// - e: {} whether we are requiring an entry, if not an entry, requiring an id with `@` will throw
function getModuleById(id, env, options) {
  var parsed;
  (options) || (options = {});

  if (!id || !options.e && ~id.indexOf('@')) {
    err("Illegal id, null or with '@'");
  }

  // `env` exists, which means the module is accessed by requiring within another module.
  if (env) {
    // pathResolve('align', 'jquery')   -> 'jquery'
    // pathResolve('align', './')
    id = pathResolve(env.id, id);
  }

  // 'a@1.0.0'    -> 'a@1.0.0'
  // 'a'          -> 'a@latest'
  // 'a/inner'    -> 'a@latest/inner'
  parsed = parseModuleId(id);

  // Suppose:
  // {
  //     'a': {
  //         '~1.2.3': '1.2.12'
  //     }
  // }

  // We route a package of certain range to a specific version, 
  // so several modules may point to a same exports

  // `NEURON_CONF` is generated by `neuron.config`
  parsed.v = NEURON_CONF.transform(parsed.v, parsed.n);
  id = formatModuleId(parsed);

  var mod = mods[id];
  if (!mod) {
    if (options.s) {
      err("Cannot find module '" + id + "'");
    }

    var pkg = formatPackageId(parsed);

    // In this case, `getModuleById` is invoked by `define`.
    if (options.m) {
      mod =
        mods[id] =
        mods[pkg] =

      // The module id of main entry is the package id.
      mods[pkg] || createModule(parsed, id, pkg);

      // There is only posibility to run `getModuleById` with `isMain` set by `true`:
      // ```
      // define(id, dependencies, factory, {main: true}). 
      // ```
      // And, before this,
      // `mods[pkg]` might have already been assigned with a falsy `id` property.

      // For example
      // {
      //     name: 'a',
      //     version: '0.0.1',
      //     main: 'lib/index.js'
      // }

      // 1. `getModuleById('a@0.0.1')`, and load 'a/0.0.1/a.js'
      // {
      //     id: 'a@0.0.1',
      //     pkg: 'a@0.0.1'
      // }

      // 2. (in a.js), define('a@0.0.1/lib/index', [], factory, {main: true})
      // Then, `getModuleById('a@0.0.1/lib/index')` will get the result of the 1st step.
      // Obviously, 
      // 'a@0.0.1' is not the real module id of the main entry,
      // while 'a@0.0.1/lib/index' is, so:
      mod.id = id;

    } else {
      mod = mods[id] = createModule(parsed, id, pkg);

      if (id === pkg) {
        mod.main = true;
      }
    }
  }

  return mod;
}


function createModule(parsed, id, pkg) {
  return {
    // package name: 'a'
    name: parsed.n,
    // package version: '1.1.0'
    version: parsed.v,
    // module path: '/b'
    path: parsed.p,
    // module id: 'a@1.1.0/b'
    id: id,
    // package id: 'a@1.1.0'
    pkg: pkg,
    // @type {Array.<function()>} callbacks
    c: [],
    // @type {Object} version map of the current module
    v: {}
  };
}


// @const
// 'a@1.2.3/abc' -> 
// ['a@1.2.3/abc', 'a', '1.2.3', '/abc']

//                    01            2         3
var REGEX_PARSE_ID = /^((?:[^\/])+?)(?:@([^\/]+))?(\/.*)?$/;
// On android 2.2,
// `[^\/]+?` will fail to do the lazy match, but `(?:[^\/]+?)` works.
// Shit, go to hell!

// @param {string} resolved path-resolved module identifier
function parseModuleId(resolved) {
  var match = resolved.match(REGEX_PARSE_ID);
  var name = match[1];

  // 'a/inner' -> 'a@latest/inner'
  var version = match[2] || 'latest';
  var path = match[3] || '';

  // There always be matches
  return {
    n: name,
    v: version,
    p: path
  };
}


// Format package id 
function formatPackageId(parsed) {
  return parsed.n + '@' + parsed.v;
}


// Format module id
function formatModuleId(parsed) {
  return formatPackageId(parsed) + parsed.p;
}


// @public
// ----------------------------------------------------------------------------------

// event support
// mix(loader, Event);


/**
 change log:
 
 import ./ChangeLog.md;
 
 */