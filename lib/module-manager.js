
// # Neuron Core 

// ## CommonJS
// Neuron 3.x or newer is not the implementation of any CommonJs proposals
// but [module/1.0](http://wiki.commonjs.org/wiki/Modules/1.0), one of the stable CommonJs standards only.
// And by using neuron and [cortex](http://github.com/kaelzhang/cortex), user could write module/1.0 modules.

// ## Naming Conventions
// All naming of variables should accord to this.
// `'a@1.0.0/relative'`

// ### package 
// The package which the current module belongs to.
// - package name: {string}  package `name`: 'a'
// - package or package id: {string}    contains package `name` and `version` and the splitter `'@'`. 'a@1.0.0' for instance.

// ### module
// A package is consist of several module objects.
// - mod: {object} the module object. use `mod` instead of `module` to avoid confliction
// - id or module id: the descripter that contains package name, version, and path information
//      {string} for example, `'a@1.0.0/relative'` is a module id(entifier)

// ### version
// Package version: '1.0.0'

// ### main entry
// The module of a package that designed to be accessed from the outside


// map -> identifier: module
var __mods = makeSureObject(neuron, 'mods');


// module define
// ---------------------------------------------------------------------------------------------------

// Method to define a module, `define` has no fault tolerance in neuron 2.0,
// because `define` method is no longer designed for human to use.
// `define` should be generated by some develop environment such as [cortex](http://ctx.io)
// @private
 
// @param {string} identifier (optional) module identifier
// @param {Array.<string>} dependencies ATTENSION! dependencies must be array of standard module identifier
//  there will be fault tolerance for argument `dependencies`. be carefull!
// @param {function(...[number])} factory
 
// @returns {undefined=}
function define (identifier, dependencies, factory, options){
    if( 
        typeof identifier === 'string' && 
        isArray(dependencies) && 
        typeof factory === 'function'
    ){
        options = options || {};

        var mod = getModuleById(identifier, null, options.main);
        mod.o = options;

        // a single module might be defined more than once.
        // use this trick to prevent module redefining, avoiding the subsequent side effect.
        // mod.f        -> already defined
        // mod.exports  -> the module initialization is done
        if( !mod.f && !mod.exports ){
            mod.f = factory;
            
            // if has dependencies
            if ( dependencies.length ) {
                mod.deps = dependencies;
                
                // ['a@0.0.1']  -> {'a' -> 'a@0.0.1'}
                generateModuleVersionMap(dependencies, mod.v);
                if ( options.asyncDeps ) {
                    generateModuleVersionMap(options.asyncDeps, mod.v);
                }

                _provide(
                    dependencies,
                    function(){
                        generateExports(mod);
                    }, mod, true
                );
                
            }else{
                // for standalone modules, run factory immediately.
                generateExports(mod);
            }

            neuron.emit('define', {
                mod: mod
            });
        }
    }
}


// 'ajax@0.0.1'
var STR_VERSION_SPLITTER = '@';

// @private
// create version info of the dependencies of current module into current sandbox
// @param {Array.<string>} modules no type detecting

// ['a@~0.1.0', 'b@~2.3.9']
// -> 
// {
//     a: '~0.1.0',
//     b: '~2.3.9'
// }
function generateModuleVersionMap (modules, host){
    modules.forEach(function(mod) {
        var name = mod.split(STR_VERSION_SPLITTER)[0];
        host[name] = mod;
    });
}


// \stable
// generate the exports if the module status is 'ready'
// @param {Object} mod
function generateExports (mod){
    var exports = {};
    var module = {
            exports: exports
        };

    // clean module properties, free memory

    // to keep the object mod away from the executing context of factory,
    // use `factory` instead `mod.f`,
    // preventing user from fetching runtime data by 'this'
    var factory = mod.f;
    factory(createRequire(mod), exports, module);
    delete mod.f;

    // during the execution of `factory`, `module.exports` might be changed
    // exports:
    // TWO ways to define the exports of a module
    // 1. 
    // exports.method1 = method1;
    // exports.method2 = method2;

    // 2.
    // module.exports = {
    //        method1: method1,
    //        method2: method2
    // }

    // priority: 2 > 1
    mod.exports = module.exports;
    
    // execute pending callbacks and clean
    mod.p.forEach(function(c){
        c();
    });
    mod.p.length = 0;
    delete mod.p;

    // never delete `mod.v`, coz `require` method might be executed after module factory executed

    //      module.exports = {
    //          abc: function() {
    //              return require('b'); 
    //          }
    //      }
    
    neuron.emit('ready', {
        mod: mod
    });
}


// module load
// ---------------------------------------------------------------------------------------------------

var GLOBAL_ENV = {
    v: {}
};


// method to load a module
// @public
// @param {Array.<String>} dependencies
// @param {(function(...[number]))=} callback (optional)
function provide (dependencies, callback){
    dependencies = makeArray(dependencies);
    
    _provide(dependencies, callback, GLOBAL_ENV);
}


// @private
// @param {Array.<String>} dependencies
// @param {(function(...[number]))=} callback (optional)
// @param {Object} env environment for cyclic detecting and generating the uri of child modules
//     {
//         r: {string} the uri that its child dependent modules referring to
//         n: {string} namespace of the current module
//     }
// @param {boolean=} noCallbackArgs whether callback method need arguments, for inner use
function _provide (dependencies, callback, env, noCallbackArgs, async){
    var counter = dependencies.length;
    var args = [];
    var cb;

    if(typeof callback === 'function'){
        cb = noCallbackArgs ?
            callback : 
            function(){
                callback.apply(null, args);
            };
    }

    dependencies.forEach(function(dep, i){
        if (dep) {
            var mod = getModuleById(dep, env);

            if ( async ) {
                mod.async = true;
            }

            registerModuleLoadCallback(mod, function(){
                if(cb){
                    -- counter;
                
                    if(!noCallbackArgs){
                        args[i] = createRequire(env)(dep);
                    }
                    
                    if(counter === 0){
                        cb();
                        args.length = 0;
                        // prevent memleak
                        cb = callback = args = null;
                    }
                }
            });
        }
    });
}


// provide 
// method to provide a module
// @private
// @param {Object} mod
// @param {function()} callback
function registerModuleLoadCallback (mod, callback){
    var loaded = !!mod.exports;
    
    // if mod is ready, it will initialize its factory function
    loaded ?
        callback()
      : mod.p.push(callback);
    
    // everytime we encounter a module which is depended by the other module, `'use'` event fires 
    neuron.emit('use', {
        mod: mod,

        // prevent duplicate loading
        // @type {boolean=} whether the module is already fetched, i.e. we don't need to fetch it from the remote server
        defined: loaded || !!mod.f
    });
}


// use the sandbox to specify the environment for every id that required in the current module 
// @param {Object} envMod mod
function createRequire (env){
    var require = function(id){
        return getModuleById(env.v[id] || id, env).exports;
    };

    require.async = function (dependencies, callback) {
        _provide(makeArray(dependencies), callback, env, false, true);
    };

    return require;
}


// cases:

// 1. calculate relative paths 
// 2. load modules

// ```
// 'a@0.0.1/b.js'
// -> define('a@0.0.1/b', ['./c'], factory, {main: true});
// if main entry is not 
// -> {
//     'a@0.0.1/b': mod_b,
//     'a@0.0.1': mod_b
// }
// -> 'a/0.0.1/a.js'

// 'a@0.0.1/c'
// -> define('a@0.0.1/c', [], factory, {});
// -> {
//     'a@0.0.1/c': mod_c
// }
// ```

// get a module by id. if not exists, a ghost module(which will be filled after its first `define`) will be created
// @param {string} id
// @param {Object} env the environment module, 
// @param {boolean} main Whether it is a main entry
function getModuleById (id, env, isMain){
    var parsed;

    // `env` exists, which means
    if ( env ) {
        // pathResolve('align', 'jquery')   -> 'jquery'
        // pathResolve('align', './')
        id = pathResolve(env.id, id);

        // 'a@1.0.0'    -> 'a@1.0.0'
        // 'a'          -> 'a@latest'
        // 'a/inner'    -> 'a@latest/inner'
        parsed = parseModuleId(id);

        // Suppose:
        // {
        //     'a': {
        //         '~1.2.3': '1.2.12'
        //     }
        // }

        // We route a package of certain range to a specific version, 
        // so several modules may point to a same exports

        // `NEURON_CONF` is generated by `neuron.config`
        parsed.v = NEURON_CONF.transform(parsed.v, parsed.n);
        id = formatModuleId(parsed);

    } else {
        parsed = parseModuleId(id);
    }

    var mod = __mods[id];
    if ( !mod ) {
        var pkg = formatPackageId(parsed);

        if ( isMain ) {
            mod = 
            __mods[id] = 
            __mods[pkg] = 

            // The module id of main entry is the package id.
            __mods[pkg] 
                || createModule(parsed, id, pkg);

            // There is only posibility to run `getModuleById` with `isMain` set by `true`:
            // ```
            // define(id, dependencies, factory, {main: true}). 
            // ```
            // And, before this,
            // `__mods[pkg]` might have already been assigned with a falsy `id` property.

            // For example
            // {
            //     name: 'a',
            //     version: '0.0.1',
            //     main: 'lib/index.js'
            // }

            // 1. `getModuleById('a@0.0.1')`, and load 'a/0.0.1/a.js'
            // {
            //     id: 'a@0.0.1',
            //     pkg: 'a@0.0.1'
            // }

            // 2. (in a.js), define('a@0.0.1/lib/index', [], factory, {main: true})
            // Then, `getModuleById('a@0.0.1/lib/index')` will get the result of the 1st step.
            // Obviously, 
            // 'a@0.0.1' is not the real module id of the main entry,
            // while 'a@0.0.1/lib/index' is, so:
            mod.id = id;

        } else {
            mod = __mods[id] = createModule(parsed, id, pkg);
        }
    }

    return mod;
}


function createModule (parsed, id, pkg){
    return {
        name    : parsed.n,
        version : parsed.v,
        path    : parsed.p,
        id      : id,
        pkg     : pkg,

        // @type {Array.<function()>} pending callbacks
        p       : [],
        // @type {Object} version map of the current module
        v       : {}
    };
}


// 'a@1.2.3/abc' -> 
// ['a@1.2.3/abc', 'a', '1.2.3', '/abc']

//                    01            2         3
var REGEX_PARSE_ID = /^([^\/]+?)(?:@([^\/]+))?(\/.*)?$/;

// @param {string} resolved path-resolved module identifier
function parseModuleId (resolved) {
    var match   = resolved.match(REGEX_PARSE_ID);
    var name    = match[1];

    // 'a/inner' -> 'a@latest/inner'
    var version = match[2] || 'latest';
    var path    = match[3] || '';

    // There always be matches
    return {
        n: name,
        v: version,
        p: path
    };
}


// Format package id 
function formatPackageId (parsed){
    return parsed.n + STR_VERSION_SPLITTER + parsed.v;
}


// Format module id
function formatModuleId (parsed) {
    return formatPackageId(parsed) + parsed.p;
}


// module tools
// ---------------------------------------------------------------------------------------------------

// greedy match:
var REGEX_DIR_MATCHER = /.*(?=\/.*$)/;

// get the current directory from the location
//
// http://jsperf.com/regex-vs-split/2
// vs: http://jsperf.com/regex-vs-split
function dirname (uri){
    var m = uri.match(REGEX_DIR_MATCHER);

    // abc/def  -> abc
    // abc      -> abc
    // abc/     -> abc
    return m ? m[0] : uri;
}


// Canonicalize path
// similar to path.resolve() of node.js
 
// pathResolve('a/b/c') ==> 'a/b/c'
// pathResolve('a/b/../c') ==> 'a/c'
// pathResolve('a/b/./c') ==> '/a/b/c'
// pathResolve('a/b/c/') ==> 'a/b/c/'
// pathResolve('a//b/c') ==> 'a//b/c'   - for 'a//b/c' is a valid uri
function pathResolve (from, to) {
    // relative
    if(to.indexOf('./') === 0 || to.indexOf('../') === 0){
        var old = (dirname(from) + '/' + to).split('/');
        var ret = [];
            
        old.forEach(function(part){
            if (part === '..') {
                ret.pop();
                
            } else if (part !== '.') {
                ret.push(part);
            }
        });
        
        to = ret.join('/');
    }
    
    return to;
}


// @public
// ----------------------------------------------------------------------------------

// event support
// mix(loader, Event);


/**
 change log:
 
 import ./ChangeLog.md;
 
 */