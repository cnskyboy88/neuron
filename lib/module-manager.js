// ## Neuron Core: Module Manager
//////////////////////////////////////////////////////////////////////

// ## CommonJS
// Neuron 3.x or newer is not the implementation of any CommonJs proposals
// but only [module/1.0](http://wiki.commonjs.org/wiki/Modules/1.0), one of the stable CommonJs standards.
// And by using neuron and [cortex](http://github.com/cortexjs/cortex), user could write module/1.0 modules.
// Just FORGET `define`.

// ## Naming Conventions of Variables
// All naming of variables should accord to this.

// Take `'a@1.0.0/relative'` for example:

// ### package 
// The package which the current module belongs to.
// - name or package name:  {string} package `name`: 'a'
// - package or package id: {string} contains package `name` and `version` and the splitter `'@'`. 
//   'a@1.0.0' for instance.

// ### module
// A package is consist of several module objects.
// - mod: {object} the module object. use `mod` instead of `module` to avoid confliction
// - id or module id: the descripter that contains package name, version, and path information
//      {string} for example, `'a@1.0.0/relative'` is a module id(entifier)

// ### version
// Package version: '1.0.0'

// ### main entry
// The module of a package that designed to be accessed from the outside


// map -> identifier: module
// Expose the object for debugging
// @expose
var mods = neuron.mods = {};


// module define
// ---------------------------------------------------------------------------------------------------

// Method to define a module.

// **NOTICE** that `define` has no fault tolerance and type checking since neuron 2.0,
// because `define` method is no longer designed for human developers to use directly.
// `define` should be generated by some develop environment such as [cortex](http://github.com/cortexjs/cortex)
// @private

// @param {string} id (optional) module identifier
// @param {Array.<string>} dependencies ATTENSION! `dependencies` must be array of standard 
//   module id and there will be NO fault tolerance for argument `dependencies`. Be carefull!
// @param {function(...[*])} factory (require, exports, module)
// @param {Object=} options

// @return {undefined}
function define(id, dependencies, factory, options) {
  (options) || (options = {});

  // When define a module,
  // there is no context dependent
  var mod = defineById(id, options.main);
  mix(mod, options);

  // A single module might be defined more than once.
  // use this trick to prevent module redefining, avoiding the subsequent side effect.
  // mod.factory        -> already defined
  // X mod.exports  -> the module initialization is done
  if (!mod.factory) {
    mod.factory = factory;

    // if has dependencies
    if (dependencies.length) {
      mod.deps = dependencies;

      // ['a@0.0.1']  -> {'a' -> 'a@0.0.1'}
      generateModuleVersionMap(dependencies, mod.v);
      var asyncDeps = options.asyncDeps;
      if (asyncDeps) {
        generateModuleVersionMap(asyncDeps, mod.v);
      }

      // pending
      loadDependencies(dependencies, function() {
        ready(mod);
      }, mod);
    } else {
      // for standalone modules, inform dependents immediately.
      ready(mod);
    }
  }
}


// Formally define a module with id,
// and dealing with the equivalent modules, merging registered callbacks.
function defineById (id, main) {
  var parsed = parseModuleId(id);
  var pkg = formatPackageId(parsed);
  var equivalents = [];
  var mod = mods[id];
  if (!mod) {
    mod = createModule(parsed, id, pkg);
  }

  if (main) {
    // If is main module
    // 'a@1.2.9/index' is equivalent to 'a@1.2.9'
    if (pkg !== id) {
      equivalents.push(pkg);
    }

    var versions = NEURON_CONF.v(parsed.v).map(function (v) {
      return parsed.n + '@' + v;
    });
    equivalents = equivalents.concat(versions);
  }

  equivalents.forEach(function (identifier) {
    var equivalent = mods[identifier];
    if (equivalent) {
      // Combine registered callbacks
      mod.c = mod.c.concat(equivalent.c);
      // Clean
      equivalent.c.length = 0;
    }

    // Set 
    mods[identifier] = mod;
  });

  // There is only posibility to run `getModuleById` with `isMain` set by `true`:
  // ```
  // define(id, dependencies, factory, {main: true}). 
  // ```
  // And, before this,
  // `mods[pkg]` might have already been assigned with a falsy `id` property.

  // For example
  // {
  //     name: 'a',
  //     version: '0.0.1',
  //     main: 'lib/index.js'
  // }

  // 1. `getModuleById('a@0.0.1')`, and load 'a/0.0.1/a.js'
  // {
  //     id: 'a@0.0.1',
  //     pkg: 'a@0.0.1'
  // }

  // 2. (in a.js), define('a@0.0.1/lib/index', [], factory, {main: true})
  // Then, `getModuleById('a@0.0.1/lib/index')` will get the result of the 1st step.
  // Obviously, 
  // 'a@0.0.1' is not the real module id of the main entry,
  // while 'a@0.0.1/lib/index' is, so:
  mod.id = id;
  return mod;
}


// cases:

// 1. calculate relative paths 
// 2. load modules

// ```
// 'a@0.0.1/b.js'
// -> define('a@0.0.1/b', ['./c'], factory, {main: true});
// if main entry is not 
// -> {
//     'a@0.0.1/b': mod_b,
//     'a@0.0.1': mod_b
// }
// -> 'a/0.0.1/a.js'

// 'a@0.0.1/c'
// -> define('a@0.0.1/c', [], factory, {});
// -> {
//     'a@0.0.1/c': mod_c
// }
// ```

// Get a module by id. 
// If not exists, a ghost module(which will be filled after its first `define`) will be created
// @param {string} id
// @param {Object} env the environment module, 
// @param {boolean} main whether is main module
// @param {boolean} strict whether is strict definition. if a module is not found, 
//   it will throw errors instead of creating a new module
function getModuleById(id, env, strict) {
  var notFound = "Cannot find module '" + id + "'";
  env || (env = {});

  // commonjs parser could not parse non-literal argument of `require`
  if (!id) {
    err('null id');
  }

  // Two kinds of id:
  // - relative module path -> 
  // - package name
  var parsed;
  var pkg;
  var relative = isPathRelative(id);
  // `env` exists, which means the module is accessed by requiring within another module.
  // `id` is something like '../abc' 
  if (relative) {
    if (!env.id) {
      err(notFound);
    }
    // pathResolve('align', './abc') -> 'align/abc'
    id = pathResolve(env.id, id);
    parsed = parseModuleId(id);
    pkg = formatPackageId(parsed);

  // `id` is something like 'jquery'
  } else {
    // 'jquery' -> 'jquery@~1.9.3'
    id = env.v && env.v[id] || id;
    // 'jquery' -> {n: 'jquery', v: 'latest', p: ''}
    // 'jquery@~1.9.3' -> {n: 'jquery', v: '~1.9.3', p: ''}
    parsed = parseModuleId(id);

    // We route a package of certain range to a specific version according to `config.tree`
    // so several modules may point to a same exports
    parsed.v = NEURON_CONF.r(parsed.v, parsed.n, env.version, env.name);
    id = pkg = formatPackageId(parsed);
  }

  var mod = mods[id];
  if (!mod) {
    if (strict) {
      err(notFound);
    }
    mod = createModule(parsed, id, pkg);
  }

  return mod;
}


function createModule(parsed, id, pkg) {
  return mods[id] = {
    // package name: 'a'
    name: parsed.n,
    // package version: '1.1.0'
    version: parsed.v,
    // module path: '/b'
    path: parsed.p,
    // module id: 'a@1.1.0/b'
    id: id,
    // package id: 'a@1.1.0'
    pkg: pkg,
    // @type {Array.<function()>} callbacks
    c: [],
    // @type {Object} version map of the current module
    v: {}
  };
}


function ready (mod) {
  // execute pending callbacks and clean
  var callbacks = mod.c;
  // We might use the same method inside the previous, then `mod.c` will be `forEach()`d.
  // So we must clean the callbacks before they are called, 
  // or the callback of the latter `use` will never be called.
  // ```
  // _use(a, function () {
  //   _use(a, function (){});
  // });
  // ```
  delete mod.c;

  callbacks.forEach(function(c) {
    c(mod);
  });
  callbacks.length = 0;

  // never delete `mod.v`, coz `require` method might be executed after module factory executed
  // ```js
  // module.exports = {
  //    abc: function() {
  //        return require('b'); 
  //    }
  // }
  // ```
}


// @private
// create version info of the dependencies of current module into current sandbox
// @param {Array.<string>} modules no type detecting
// @param {Object} host

// ['a@~0.1.0', 'b@~2.3.9']
// -> 
// {
//     a: '~0.1.0',
//     b: '~2.3.9'
// }
function generateModuleVersionMap(modules, host) {
  modules.forEach(function(mod) {
    var name = mod.split('@')[0];
    host[name] = mod;
  });
}


// Generate the exports
// @param {Object} mod
function getExports(mod) {
  // Since 6.0.0, neuron will not emit a "cyclic" event.
  // But, detecing static cyclic dependencies is a piece of cake for compilers, 
  // such as [cortex](http://github.com/cortexjs/cortex)
  var exports = mod.loaded
    ? mod.exports

    // #82: since 4.5.0, a module only initialize factory functions when `require()`d.
    // A single module might
    : generateExports(mod);

  return exports;
}


function generateExports (mod) {
  var exports = {};
  // @expose
  var module = {
    exports: exports
  };

  // # 85
  // Before module factory being invoked, mark the module as `loaded`
  // so we will not execute the factory function again.
  
  // `mod.loaded` indicates that a module has already been `require()`d
  // When there are cyclic dependencies, neuron will not fail.
  mod.loaded = true;

  // to keep the object mod away from the executing context of factory,
  // use `factory` instead `mod.factory`,
  // preventing user from fetching runtime data by 'this'
  var factory = mod.factory;
  factory(createRequire(mod), exports, module);
  // delete mod.factory;

  // during the execution of `factory`, `module.exports` might be changed
  // exports:
  // TWO ways to define the exports of a module
  // 1. 
  // exports.method1 = method1;
  // exports.method2 = method2;

  // 2.
  // module.exports = {
  //        method1: method1,
  //        method2: method2
  // }

  // priority: 2 > 1
  return mod.exports = module.exports;
}


// function emit (mod, type) {
//   neuron.emit(type, {
//     mod: mod
//   });
// }

// module load
// ---------------------------------------------------------------------------------------------------

// @private
// @param {Array.<String>} dependencies
// @param {(function()} callback
// @param {Object} env Environment for cyclic detecting and generating the uri of child modules
// {
//     r: {string} the uri that its child dependent modules referring to
//     n: {string} namespace of the current module
// }
function loadDependencies(dependencies, callback, env) {
  var counter = dependencies.length;

  dependencies.forEach(function(id) {
    if (id) {
      var mod = getModuleById(id, env);
      registerModuleLoadCallback(mod, function() {
        if (--counter === 0) {
          callback();

          // prevent memleak
          callback = NULL;
        }
      }, env);

      // Prevent bad dependencies
    } else {
      --counter;
    }
  });
}


function useModule (mod, callback) {
  registerModuleLoadCallback(mod, function (mod) {
    callback(getExports(mod));
  });
}


// provide a module
// method to provide a module
// @param {Object} mod
// @param {function()} callback
function registerModuleLoadCallback(mod, callback) {
  mod.c
    ? mod.c.push(callback)
    : callback(mod);

  if (!mod.factory) {
    loadByModule(mod);
  }
}


// Since 4.2.0, neuron would not allow to require an id with version
function testRequireId (id) {
  if (~id.indexOf('@')) {
    err("id with '@' is prohibited");
  }
}


// use the sandbox to specify the environment for every id that required in the current module 
// @param {Object} env The object of the current module.
// @return {function}
function createRequire(env) {
  var require = function(id) {
    // `require('a@0.0.0')` is prohibited.
    testRequireId(id);

    var mod = getModuleById(id, env, true);
    return getExports(mod);
  };

  // @param {string} id Module identifier. 
  // Since 4.2.0, we only allow to asynchronously load a single module
  require.async = function(id, callback) {
    if (callback) {
      // `require.async('a@0.0.0')` is prohibited
      testRequireId(id);

      var mod = getModuleById(id, env);
      if (!mod.main) {
        if (isPathRelative(id)) {
          // If user try to load a non-entry module, it will get a 404 response
          mod.a = true;
        } else {
          // We only allow to `require.async` main module or entries of the current package 
          return;
        }
      }

      useModule(mod, callback);
    }
  };

  // @param {string} path
  // @returns
  // - {string} if valid
  // - otherwise `undefined`
  require.resolve = function (path) {
    // NO, you should not do this:
    // `require.resolve('jquery')`
    // We only allow to resolve a relative path

    // Trying to load the resources of a foreign package is evil.
    if (isPathRelative(path)) {
      path = pathResolve(env.path, path);

      // If user try to resolve a url outside the current package
      // it fails silently
      if (!~path.indexOf('../')) {
        return absolutizeURL(moduleId2RelativeURLPath(env.pkg + path));
      }
    }
  };

  return require;
}


// Format package id 
function formatPackageId(parsed) {
  return parsed.n + '@' + parsed.v;
}
